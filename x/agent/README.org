#+TITLE: Group Module
#+BEGIN_SRC go :tangle types.go :exports none
  // GENERATED FROM README.org
  // DO NOT EDIT THIS FILE DIRECTLY!!!!!
  package data

  import (
    sdk "github.com/cosmos/cosmos-sdk/types"
  )
#+END_SRC

* Overview

  The group module provides a mechanism that can be used to support basic multi-party organizations and to allow individuals to authorize their own transactions via multiple keys on different devices (key groups). In the future, it may be extended to support more sophisticated multi-party authorization schemes.

* Motivation
  There are a number of scenarios where we want to model a group or organization concept on the blockchain. Here are some hypothesized groups that this module should serve:

** Regen Consortium and its member organizations
   The Regen Consortium is intended to be the group of organizations that govern the Regen Ledger blockchain. They get to choose the validator set, decide on major upgrades to the blockchain as well as a number of parameters like transaction fees. Each consortium member itself must be an organization that likely has its own decision making policy.

** Protocol and Contract Curators
   Ecological state protocols (ESPs) and contracts (ECs) have been theorized to specify some organization or group that "curates" them. Curation has a number of different benefits and responsibilities. ESP curators have the responsibility of upgrading the protocols over time and may also receive curator fees when ESPs are run. EC curators may also receive a fee and/or be required to intervene to arbitrate terms of a contract.

** Verifiers
   It is hypothesized that verifiers may likely be multi-party organizations that have their own governance protocol for approving verification claims.

* Transaction Messages and Types
** Basic Types
#+BEGIN_SRC go :tangle types.go
// A group can be used to abstract over users and groups.
// It could be used to group individuals into a group or several groups/users into a larger group.
// It could be used by a single user to manage multiple devices and setup a multisig policy.
type Group struct {
  // The members of the group and their associated power
	Members         []Member `json:"addresses,omitempty"`
  // Specifies the number of votes that must be accumulated in order for a decision to be made by the group.
  // A member gets as many votes as is indicated by their Power field.
  // A big integer is used here to avoid any potential vulnerabilities from overflow errors
  // where large power and threshold values are used.
	Threshold big.Int `json:"threshold"`
  // TODO maybe make this something more specific to a domain name or a claim on identity? or Memo leave it generic
	Memo              string           `json:"memo,omitempty"`
}

// A member specifies a address and a power for a group member
type Member struct {
  // The address of a group member. Can be another group or a contract
  Address sdk.AccAddress `json:"address"`
  // The integral power of this member with respect to other members and the decision threshold
  Power big.Int `json:"power,omitempty"`
}
#+END_SRC go
** ~MsgCreateAgent~
   
#+BEGIN_SRC go :tangle types.go
// Creates a group on the blockchain
// Should return a tag "group.id" with the bech32 address of the group
type MsgCreateGroup struct {
	Data   Group      `json:"data"`
	Signer sdk.AccAddress `json:"signer"`
}
#+END_SRC go
*** TODO transaction fee

* Identifiers
  Groups implement the ~Account~ interface and thus have an ~AccAddress~. Internally an group ID is an ~uint64~ which is assigned on an auto-increment basis. The ~AccAddress~ for an group is made by concatenating the prefix ~G~ (as ~[]byte~) and the [[https://golang.org/pkg/encoding/binary/#PutUvarint][varint]] encoding of the ~uint64~ account ID. The textual representation of an group account is obtained by taking the bech32 encoding of this ~AccAddress~ with the prefix ~xrn:~ which also is a valid URI.

* Indexing and Queries
** ~get~
   The ~get~ query command should take the group address as a single parameter retrieve the current ~Group~ struct (as JSON) associated with that address
** Postgresql
   Groups and their members should be indexed to the tables below which should allow members to look up any groups they are directly or transitively part of:

#+BEGIN_SRC sql :tangle group.sql
  CREATE TABLE group (
    address text NOT NULL PRIMARY KEY,
    threshold NUMERIC NOT NULL 
  );
  
  CREATE TABLE group_member (
    group text NOT NULL REFERENCES group,
    address text NOT NULL,
    power NUMERIC NOT NULL
  )
#+END_SRC go
