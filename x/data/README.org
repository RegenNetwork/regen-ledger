#+TITLE: Data Module
*STATUS: PARTIAL*
* Overview
  :PROPERTIES:
  :CUSTOM_ID: overview
  :END:

This module provides very basic support for hashing and time-stamping data onto
the blockchain. It serves the purpose of providing a way that any piece of data
can be tracked onto the blockchain for a fee and known to have existed at or
before some given block-height. It is intended that this module will mostly
be supplanted by other more domain specific functionality and/or
enhanced with robust, opt-in schema-validation support in the future.

* Motivation and Rationale
  

** Requirements
  :PROPERTIES:
  :CUSTOM_ID: overview
  :END:

- It should be possible to store arbitrary data on the blockchain for a fee
- It should be possible to track arbitrary off-chain data by hash on the blockchain, thus generating a proof of timestamp
- On-chain and off-chain data should be available in the index available to oracles
- There must be a robust way for dealing with hash collisions, especially with respect to off-chain data whose content is opaque

* Transaction Messages and Types
#+BEGIN_SRC go :tangle types.go :exports none
  // GENERATED FROM README.org
  // DO NOT EDIT THIS FILE DIRECTLY!!!!!
  package data

  import (
    sdk "github.com/cosmos/cosmos-sdk/types"
  )
#+END_SRC

** Store RDF graph on-chain

#+BEGIN_SRC go :tangle types.go
  type MsgStoreGraph struct {
    // RDF graph data in N-Triples text format
    NTriples string `json:"ntriples"`
	  // Expected hash of the graph. The transaction will be rejected if this hash can't be verified.
    URDNA2015_BLAKE2B_256_Hash []byte `json:"urdna2015_blake2b_256_hash"`
    Signer sdk.AccAddress `json:"signer"`
  }
#+END_SRC

[[https://www.w3.org/TR/n-triples/][N-Triples]] format has been chosen as a starting point because it is easy to parse and self-contained.

*** NOTE The reason JSON-LD has not been chosen for on-chain usage is that the way `@context` is designed explicitly requires JSON-LD processors to pull off-chain HTTP data which is indeterministic.

*** TODO In the future, we would like to support other self-contained formats such as Turtle and binary formats.

*** TODO Should the URDNA2015 hash be verified on chain or should this be left to indexers?
    The danger with doing it on-chain now is that there currently is no known algorithm for verifying that a graph is normalized that is guaranteed to terminate in linear time: https://github.com/json-ld/normalization/issues/11.

    A short-term workaround would be to only allow graphs that have no blank nodes. Then verifying that data is normalized is simply a matter of verifying that it's sorted. Then in the future we can allow graphs with blank nodes when we have a way of verifying that blank nodes have been assigned canonically.

*** TODO should data format (i.e. JSON/JSON-LD/etc.) and/or schema (i.e. SCHACL/SHEX/JSON-SCHEMA) be tracked and/or verified on-chain?
    It might be useful to track format on-chain but not verify it. For a given format there could be multiple schemas that it satisfies. My current thoughts are that this is a type of verification/validation that can be done off chain and there can be on-chain attestations about that - ARC.

** Store arbitrary data on-chain
   
#+BEGIN_SRC go :tangle types.go
  type DataFormat int

  const (
    Unknown DataFormat = 0
    JSON_LD DataFormat = 1
    NQuads DataFormat  = 2
    Turtle DataFormat  = 3
    TriG DataFormat    = 4
    JSON DataFormat    = 5
    XML DataFormat     = 6
    YAML DataFormat    = 7
    TIFF DataFormat    = 8
  )

  type MsgStoreData struct {
  	//SchemaRef string
  	Data []byte `json:"data"`
    Format DataFormat `json:"format,omitempty"`
  	Signer sdk.AccAddress `json:"signer"`
  }
#+END_SRC

** Track off-chain RDF dataset

#+BEGIN_SRC go :tangle types.go
  type HashAlgorithm int

  const (
    BLAKE2B_256 HashAlgorithm = 0
    SHA256 HashAlgorithm = 1
    URDNA2015 HashAlgorithm = 2
    URGNA2012 HashAlgorithm = 3
  )

  type MsgTrackData struct {
    Hash []byte `json:"hash"`
    Algorithm HashAlgorithm `json:"algorithm"`
    Format DataFormat `json:"format,omitempty"`
    Url string `json:"url,omitempty"`
  }
#+END_SRC

* Queries and Indexing
