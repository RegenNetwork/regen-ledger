#+TITLE: Data Module
*STATUS: PARTIAL*
* Overview
  :PROPERTIES:
  :CUSTOM_ID: overview
  :END:

This module provides very basic support for hashing and time-stamping data onto
the blockchain. It serves the purpose of providing a way that any piece of data
can be tracked onto the blockchain for a fee and known to have existed at or
before some given block-height. It is intended that this module will mostly
be supplanted by other more domain specific functionality and/or
enhanced with robust, opt-in schema-validation support in the future.

* Motivation and Rationale
  

** Requirements
  :PROPERTIES:
  :CUSTOM_ID: overview
  :END:

- It should be possible to store arbitrary data on the blockchain for a fee
- It should be possible to track arbitrary off-chain data by hash on the blockchain, thus generating a proof of timestamp
- On-chain and off-chain data should be available in the index available to oracles
- There must be a robust way for dealing with hash collisions, especially with respect to off-chain data whose content is opaque

* Transaction Messages and Types
#+BEGIN_SRC go :tangle types.go :exports none
  // GENERATED FROM README.org
  // DO NOT EDIT THIS FILE DIRECTLY!!!!!
  package data

  import (
    sdk "github.com/cosmos/cosmos-sdk/types"
  )
#+END_SRC

** Store RDF graph on-chain

#+BEGIN_SRC go :tangle types.go
  type MsgStoreGraph struct {
    // RDF graph data in N-Triples text format
    NTriples string `json:"ntriples"`
	  // Expected hash of the graph. The transaction will be rejected if this hash can't be verified.
    URDNA2015_BLAKE2B_256_Hash []byte `json:"urdna2015_blake2b_256_hash"`
    Signer sdk.AccAddress `json:"signer"`
  }
#+END_SRC

[[https://www.w3.org/TR/n-triples/][N-Triples]] format has been chosen as a starting point because it is easy to parse and self-contained.

*** NOTE The reason JSON-LD has not been chosen for on-chain usage is that the way `@context` is designed explicitly requires JSON-LD processors to pull off-chain HTTP data which is indeterministic.

*** TODO In the future, we would like to support other self-contained formats such as Turtle and binary formats.

*** TODO Should the URDNA2015 hash be verified on chain or should this be left to indexers?
    The danger with doing it on-chain now is that there currently is no known algorithm for verifying that a graph is normalized that is guaranteed to terminate in linear time: https://github.com/json-ld/normalization/issues/11.

    A short-term workaround would be to only allow graphs that have no blank nodes. Then verifying that data is normalized is simply a matter of verifying that it's sorted. Then in the future we can allow graphs with blank nodes when we have a way of verifying that blank nodes have been assigned canonically.

*** TODO should data format (i.e. JSON/JSON-LD/etc.) and/or schema (i.e. SCHACL/SHEX/JSON-SCHEMA) be tracked and/or verified on-chain?
    It might be useful to track format on-chain but not verify it. For a given format there could be multiple schemas that it satisfies. My current thoughts are that this is a type of verification/validation that can be done off chain and there can be on-chain attestations about that - ARC.

** Store arbitrary data on-chain
   
#+BEGIN_SRC go :tangle types.go
  type DataFormat int

  const (
    Unknown DataFormat = 0
    JSON_LD DataFormat = 1
    NQuads DataFormat  = 2
    Turtle DataFormat  = 3
    TriG DataFormat    = 4
    JSON DataFormat    = 5
    XML DataFormat     = 6
    YAML DataFormat    = 7
    TIFF DataFormat    = 8
  )

  type MsgStoreData struct {
  	//SchemaRef string
  	Data []byte `json:"data"`
    Format DataFormat `json:"format,omitempty"`
  	Signer sdk.AccAddress `json:"signer"`
  }
#+END_SRC

** Track off-chain RDF dataset

#+BEGIN_SRC go :tangle types.go
  type HashAlgorithm int

  const (
    BLAKE2B_256 HashAlgorithm = 0
    SHA256 HashAlgorithm = 1
    URDNA2015 HashAlgorithm = 2
    URGNA2012 HashAlgorithm = 3
  )

  type MsgTrackData struct {
    Hash []byte `json:"hash"`
    Algorithm HashAlgorithm `json:"algorithm"`
    Format DataFormat `json:"format,omitempty"`
    Url string `json:"url,omitempty"`
  }
#+END_SRC
* Identifiers
** On-chain graphs
   On-chain graphs are identified by the URI formed by encoding the URNDNA2015_BLAKE2B_256 hash of the graph with the prefix ~xrn://<block-number>/g/~.
** Off-chain datasets
   Off-chain datasets are identified by the URI formed by encoding the URNDNA2015_BLAKE2B_256 hash of the dataset with the prefix ~xrn://<block-number>/ds/~.
** On-chain raw data
   On-chain raw data is identified by the URI formed by encoding the Blake2b 256-bit hash of the data prefixed with ~xrn://<block-number>/da/~.
** Off-chain raw data
   Off-chain raw data is identified by the URI formed by encoding the Blake2b 256-bit hash of the data prefixed with ~xrn://<block-number>/dt/~.
* Indexing and Queries
** Postgresql
#+BEGIN_SRC sql :tangle data.sql
  CREATE TABLE "data" (
    uri text NOT NULL PRIMARY KEY,
    tx bytea NOT NULL REFERENCES tx,
    graph jsonb,
    raw_data bytea
  );

  COMMENT ON COLUMN graph.graph IS 'The JSON-LD expanded form representation of an on-chain graph';

  COMMENT ON COLUMN graph.raw_data IS 'Raw data bytes for on-chain raw data';
#+END_SRC
** RDF
*** On-chain graphs
    On chain graphs are indexed in the RDF store in the named graph identified with the graph identifier URI. They are annotated in the default graph as follows (where ~xrn://12345/g/1xq52sutm~ is an example graph URI):

#+BEGIN_SRC turtle
PREFIX xrn: <http://regen.network/schema#>

<xrn://12345/g/1xq52sutm>
  xrn:tx <xrn://12345/tx/abcdef1234567> .
#+END_SRC
